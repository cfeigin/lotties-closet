# Lottie's Closet Design 

---

## Overarching Structure
Lottie's Closet is a Flask app that stores user data (e.g. username, sizing) in a SQL database called closet.db. The app's main search function utilizes a call to OpenAI's GPT-5-Nano API engine to process and optimize the user's natural language query. The optimized query generated by OpenAI is then sent as input to SerpAPI's Google Shopping engine, whose output is rendered into visual cards.

---

## app.py
`app.py` is adapted from the CS50 Finance pset and contains the functionality for each possible route of the web app. Each is detailed below: 

### index
If a user navigates to the home page via a GET request, this function simply renders the home page via `render_template`. Otherwise, if a user makes a search on the home page via POST, `index` will get the user's search via `request.form.get("query")` and get shopping output via OpenAI and SerpAPI as detailed in the "APIs" section below. The shopping data will be sent to `index.html` via the named parameter `results`, along with the user's name, extracted from the `users` table in `closet.db` (also detailed below). 

### login and logout
These functions are the same as those of the CS50 Finance pset. They require login to access all other routes via the `@login_required` wrapper and clear the Flask session upon logout.  

### register
If a user navigates to the register page via a GET request, this function simply renders the registration form via `render_template`. Otherwise, if a user submits a registration form via a POST request, this function will sanitize user input on the backend. If any input is deemed invalid (i.e. missing information or username already in use), `apology.html` will be rendered. If all information is valid, a new `users` entry will be created via `INSERT INTO users (name, username, hash) VALUES ({name}, {username}, {generated password hash})`.

### preferences
If a user navigates to the preferences page via a GET request, this function simply renders the preferences form via `render_template`. Otherwise, if a user submits a their preferences via a POST request, this function will sanitize user input on the backend. All inputted info is stored in a dict called `info`. For each field on the form, if the user inputted anything, the input will be checked for validity (e.g. shoe size must be a positive multiple of 0.5). If any input is deemed invalid, an apology will be rendered. Once all input is sanitized, the SQLite command `INSERT INTO preferences (user_id) VALUES ({ user id })` is run within a `try` block to create a `preferences` entry if this is a user's first time submitting the form. If the user has an exiting entry, this query will throw a ValueError, which will be caught by the `except` block. From there, the function loops through the `info` dict and if a value exists, will UPDATE the user's `preferences` entry to reflect the inputted value. If the user leaves a field blank, it is stored as NULL in `closet.db`. 

### history
This function renders `history.html`, which displays the user's saved sizing preferences. It does so via the SQLite query `SELECT * FROM preferences WHERE user_id = {user id}`, which is then sent under the alias `entry` to `render_template`.

## helpers.py
The code in helpers.py is adaped from the CS50 Finance pset and includes a `login_required` wrapper, as well as a simplified `apology` function to render error messages.

---

## Static
The static folder includes the web app's logo as `favicon.ico`, the apology image as `hanger.png`, and the styling, organized in a top-down manner, in `styles.css`.

---

## Templates
All templates other than `layout.html` extend boilerplate `layout.html` (with navbar, footer, etc.) via Jinja's `{% extends "layout.html" %}`. 

### apology.html
A clean and simple apology is rendered as a card. I also adapted a simple fade-in effect from ChatGPT via the `@keyframes fadeIn` wrapper in `styles.css`.

### history.html
User preferences are displayed. Content is justified via: `justify-content: space-between;` in `styles.css`.

### index.html
A jinja conditional `{% if results %}` is used to determine whether or not the user had just searched for an item. If `results` is None, only the search bar is rendered. If `results` exists, the JSON SerpAPI output (which is what is stored in the list `results`) are rendered as Bootstrap cards. From the SerpAPI documentation, I found that each JSON returned by SerpAPI has the relevant fields `thumbnail`, `title`, `price`, `source`, and `link`, which I rendered in the cards. For each one, I first checked that they existed (e.g. `{% if item.link %}`), since SerpAPI does not guarantee that all fields will be filled, and I then included their values in the HTML via Jinja's `{{ variable }}` notation. 

### login.html, preferences.html, and register.html
These three pages are quite similar, hence shared CSS classes such as `.bubble` in `styles.css` ensuring a consistent user interface.

---

## closet.db 
**Important**: All SQLite queries in this file are modified to include {} notation for readibility. In the actual project files, the "?" is always used to avoid potential SQL injection attacks.

All user data is stored in the SQLite database closet.db. The database contains two tables: `users` and `preferences`. The `users` table is primarily accessed upon account registration, whereby an entry with the new user's desired `name` and `username` are stored in an entry along with an auto-incremented unique `id` and a securely-generated password `hash` to ensure that the user's actual password cannot be leaked in a data breach. 

The `preferences` database is accessed in a number of places. It contains 11 columns: an auto-incremented, unique `id`, a `user_id` foreign key referencing the `user` table's `id` field, the user's `gender`, `height_feet`, `height_in`, `weight`, `top_size`, `bottom_size`, `dress_size`, `shoe_size`, and `shoe_gender`. Since all fields in the preferences form are optional, all corresponding columns in the `preferences` database may take the value of NULL. Since the `user_id` column is a UNIQUE and NOT NULL INTEGER, there is one entry per user. THe `preferences` route in `app.py` creates/updates entry in this table, whereas the `search` and `history` functions access its contents to respectively personalize search queries and display user preferences. Since both functions SELECT from the table WHERE user_id = session["user_id"], I have created a UNIQUE INDEX on the `user_id` field to maximize speed and efficiency. Additionally, since a number of pages access the `users` table to display the user's name, I have created a non-unique INDEX on the `name` field.

---

## APIs
This project utilizes two APIs: OpenAI and SerpAPI. This is because a search performs two functions: optimizing the user's search query and scraping the internet for shopping results. OpenAI is useful for optimizing the query via its natural language processing abilities, but it is unable to effectively scrape the internet. As such, the program sends the optimized query to SerpAPI, a Google search engine that allows for efficient internet scraping. The specifications for each API are detailed below: 

### OpenAI API
I chose to use OpenAI's GPT-5-Nano engine because search query optimization is a very low-tech request, and the GPT-5-Nano model was by far the cheapest. Calling the API was quite easy to implement via `client.responses.create()` with named parameters `model`, `input`, and `instructions`. I crafted a user prompt that would produce the output I desired: "Create a succinct and effective search query to find clothing items based on the following user preferences: User's search: {user query}. User's preferences/sizing information: {that user's info in the `preferences` table}. Use only keywords and information relevant to the user's search. Capture the essence of the user's search, but remove/adjust any extraneous words or fluff. If the user's preferences/sizes do not relate to the search or are not included, ignore them. You should only be using one size, if any. The query should be optimized for searching on Google Shopping." To ensure the structure of the output, I included the system prompt: "Limit your response to the query itself. Make it as concise as possible." Finally, I used the call `response.output_text.strip()` to get the AI's reponse without any extraneous whitespace. 

### SerpAPI
With an optimized query, I was then able to call SerpAPI. SerpAPI is a Google Search API that returns structured JSON output, which worked perfectly with my web application. I used its google_shopping engine to limit results to Google Shopping products instead of general Google search output. After creating a client, I was able to call the API via `GoogleSearch(params)`, whereby `params` was a dict containing, among others, a field for the search query as `q`. I called the API inside of a `try` block to ensure that any error in fetching results didn't crash my program. To extract the API's JSON output, I used the call `search.get_dict().get("shopping_results", [])` to store each JSON (i.e. each shopping result) in a list. Since the API can return thousands of results, I limited the list to the first 21 results (or fewer, if fewer than 21 results were found) and sent the list of JSONs to `index.html` to render. 

**Side Note**: I only get 250 free API calls on my account, so if possible please try to limit the number of calls so that I can have some leeway to demonstrate my product at the fair! If I go over 250, I'll have to pay $75 :(

### .gitignore
To protect my own data, I stored my API keys in a `.env` file, which I included in `.gitignore` to ensure that they remained hidden.
