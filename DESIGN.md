# Lottie's Closet Design 

---

## Overarching Structure
Lottie's Closet is a Flask app that stores user data (e.g. username, sizing) in a SQL database called closet.db. The app's main search function utilizes OpenAI's GPT-5-Nano API engine to process and optimize the user's natural language query. The optimized query generated by OpenAI is then sent as input to SerpAPI's Google Shopping engine, whose output is rendered into visual output.

---

## app.py
`app.py` is adapted from the CS50 Finance pset and contains the functionality for each of the web app's routes. Said routes are detailed below: 

### index
If a user navigates to the home page via GET request, this function simply renders the home page (via `render_template`). Otherwise, if a user makes a search on the home page via POST, `index` will get the user's search via `request.form.get("query")` and fetch relevant shopping results via OpenAI and SerpAPI as detailed in the "APIs" section below. The shopping data will be sent to `index.html` via the named parameter `results`, along with the user's name, which is extracted from the `users` table in `closet.db` (also detailed below). 

### login and logout
These functions are taken from the CS50 Finance pset. `login` and `logout` utilize Flask sessions by storing the user's id number in `session["user_id"]` and removing it via `session.clear()` when desired.  

### register
If a user navigates to the register page via GET request, this function simply renders the registration form (via `render_template`). Otherwise, if a user submits a registration form via POST, this function will sanitize user input on the backend. If any input is deemed invalid (i.e. missing information or username already in use), `apology.html` will be rendered. If all information is valid, a new `users` entry will be created via `INSERT INTO users (name, username, hash) VALUES ({name}, {username}, {generated password hash})`.

### preferences
If a user navigates to the preferences page via GET request, this function simply renders the preferences form (via `render_template`). Otherwise, if a user submits a their preferences via POST, this function will sanitize user input on the backend. All inputted information is stored in a dict named `info`. For each key-value pair in `info`, if the value exists (i.e. if the user answered that question on the preferences form), the user's input will be checked for validity (e.g. shoe size must be a positive multiple of 0.5). If any input is deemed invalid, an apology will be rendered. Once all input is sanitized, the SQLite command `INSERT INTO preferences (user_id) VALUES ({ user id })` is run within a `try` block to create a new `preferences` entry if this is a user's first time submitting the form. If the user has an exiting entry, this SQLite query will throw a ValueError, which will be caught in the `except` block. From there, the function loops through the `info` dict and if a value exists, the user's `preferences` entry will be UPDATEd to reflect the new value. If the user leaves a field blank, it is stored as NULL. 

### history
This function renders `history.html`, which displays the user's saved sizing preferences. It does so via the SQLite query `SELECT * FROM preferences WHERE user_id = {user id}`, which is then sent under the alias `entry` to `render_template`.

## helpers.py
The code in helpers.py is adaped from the CS50 Finance pset and includes a `login_required` wrapper, as well as a simplified `apology` function to render error messages.

---

## Static
The static folder includes the web app's logo as `favicon.ico`, the apology hanger icon as `hanger.png`, and the styling in `styles.css`. Styling is implemented in a top-down manner, with style choices for higher-level elements naturally cascading down to lower-level elements.

---

## Templates
All templates extend boilerplate `layout.html` (which includes the navbar, footer, etc.) via Jinja's `{% extends "layout.html" %}`. 

### apology.html
A clean and simple apology is rendered as a card. I also adapted a simple fade-in effect from ChatGPT via the `@keyframes fadeIn` wrapper in `styles.css`.

### history.html
User preferences are displayed. Content is justified via: `justify-content: space-between;` in `styles.css`.

### index.html
A Jinja conditional `{% if results %}` is used to determine whether or not the user expects to view shopping results. If `results` is None, only the search bar is rendered. If `results` exists, the SerpAPI output (JSONs stored in the list `results`) is rendered as Bootstrap cards. From the SerpAPI documentation, I found that each JSON returned by SerpAPI has the relevant fields `thumbnail`, `title`, `price`, `source`, and `link`, which I included in the cards for the best user experience. For each field, I made sure to check that they existed (e.g. `{% if item.link %}`) before rendering them, since SerpAPI does not guarantee that all fields will be filled. 

### login.html, preferences.html, and register.html
These three pages are quite similar to each other, hence shared CSS classes such as `.bubble` in `styles.css` ensuring a consistent user interface. Each page displays an HTML form that sends a POST request to the relevant route. In `preferences.html`, fields are populated if the user already has saved information. I did this by adding the `selected` attribute to each `<option>` and then surrounding each with Jinja conditionals that would only allow for one `<option>` to be selected, depending on the value (or lack thereof) of that field in the `preferences` table. For `<input>`s, I set the `value` attribute to the value stored in the `preferences` table for that field, and then surrounded it with a Jinja conditional that would only proceed if that data existed.

---

## closet.db 
**Important**: All SQLite queries in this `DESIGN.md` file are modified to include {} notation for ease of readibility. In the actual project files, the "?" placeholder is always used to avoid SQL injection attacks.

All user data is stored in the SQLite database `closet.db`. The database contains two tables: `users` and `preferences`. The `users` table is primarily accessed upon account registration, whereby an entry with the new user's desired `name` and `username` along with an auto-incremented unique `id` and a securely-generated password `hash` (to ensure that the user's actual password cannot be leaked in a data breach) is created. 

The `preferences` database is accessed in a number of places. It contains 11 columns: an auto-incremented, unique `id`, a `user_id` foreign key referencing the `user` table's `id` field, the user's `gender`, `height_feet`, `height_in`, `weight`, `top_size`, `bottom_size`, `dress_size`, `shoe_size`, and `shoe_gender`. Since all fields in the preferences form are optional, all corresponding columns in the `preferences` database accept a value of NULL. Since the `user_id` column is a UNIQUE and NOT NULL INTEGER, there is one entry in the `preferences` table per user. The `preferences` route in `app.py` creates/updates entries in this table, whereas the `search` and `history` routes read its contents to personalize search queries and display user preferences. Since both functions SELECT from the table WHERE user_id = session["user_id"], I have created a UNIQUE INDEX on the `user_id` field to maximize speed and efficiency. Additionally, since a number of routss access the `users` table to display the user's name, I have created a non-unique INDEX on the `name` field for the same purpose.

---

## APIs
This project uses two APIs: OpenAI and SerpAPI. This is because a search on Lottie's Closet performs two functions: optimizing the user's search query and scraping the internet for shopping results. OpenAI is useful for optimizing the query due to its natural language processing capabilities, but it is unable to effectively scrape the internet. As such, the program sends the optimized query to SerpAPI, a Google Search engine that allows for simple and efficient internet scraping. The specifications for each API are detailed below: 

### OpenAI API
I chose to use OpenAI's GPT-5-Nano engine because search query optimization is a very low-tech task, and the GPT-5-Nano model was by far the cheapest. Calling the API required calling `client.responses.create()` with named parameters `model`, `input`, and `instructions`. I crafted the following user prompt (`input`) to produce the output I desired: "Create a succinct and effective search query to find clothing items based on the following user preferences: User's search: {user query}. User's preferences/sizing information: {that user's info from the `preferences` table}. Use only keywords and information relevant to the user's search. Capture the essence of the user's search, but remove/adjust any extraneous words or fluff. If the user's preferences/sizes do not relate to the search or are not included, ignore them. You should only be using one size, if any. The query should be optimized for searching on Google Shopping." To ensure the structure of the output, I included the following system prompt (`instructions`): "Limit your response to the query itself. Make it as concise as possible." Finally, I called `response.output_text.strip()` to get the AI's reponse without any extraneous whitespace. 

### SerpAPI
With an optimized query, I was then able to call SerpAPI. SerpAPI is a Google Search API that returns structured JSON output, which worked quite well with my web application. I used its google_shopping engine to limit results to Google Shopping products instead of general Google search output. After creating a client, I was called the API via `GoogleSearch(params)`, whereby `params` was a dict containing a field for the search query (`q`). I called the API inside of a `try` block to ensure that any error in fetching results didn't crash my program. To extract the API's JSON output, I used the call `search.get_dict().get("shopping_results", [])` to store each JSON (i.e. each shopping result) in a list called `shopping_results`. Since the API can return thousands of results, I limited the list to the first 21 results (or fewer, if fewer than 21 results were found) and sent the list of JSONs to `index.html` to render. 

### .gitignore
To protect my own data, I stored my API keys in a `.env` file, which I included in `.gitignore` to ensure that they remained hidden.
